

# 基础知识：
## 网络：
 ### http
1. 版本区别
HTTP/1.0、HTTP/1.1 和 HTTP/2 是 HTTP 协议的三个主要版本，它们之间存在一些关键区别：

 HTTP/1.0（1996年发布）：[短连接、不支持持久连接、无压缩传输、请求头和相应头没有大小限制]

仅支持短连接，即每次请求都需要建立新的 TCP 连接，请求结束后关闭连接。这会导致较高的网络延迟和带宽消耗。
不支持持久连接（Keep-Alive），即在一个 TCP 连接中同时发送多个请求。
无压缩传输，导致数据冗余和带宽浪费。
请求和响应头字段没有大小限制。
HTTP/1.1（1999年发布）：

- 支持持久连接（Keep-Alive），允许在一个 TCP 连接中同时发送多个请求，降低了网络延迟和带宽消耗。
管道化（Pipelining），允许客户端同时发送多个请求，而无需等待响应。这进一步提高了性能。
支持分块传输编码（Chunked Transfer Encoding），允许服务器在传输大文件时分块发送，减少等待时间和占用内存的问题。
请求和响应头字段有大小限制（通常为 8KB）。
HTTP/2（2015年发布）：

- 多路复用（Multiplexing），允许在一个 TCP 连接中同时发送多个请求和响应，解决了 HTTP/1.1 中的队头阻塞问题。
服务器推送（Server Push），允许服务器预测客户端可能需要的资源，并在客户端发送请求之前主动推送这些资源。
数据流优先级（Stream Prioritization），允许客户端和服务器为请求和响应设置优先级，确保重要请求得到及时处理。
头部压缩（Header Compression），使用 HPACK 算法对请求和响应头字段进行压缩，降低了网络延迟和带宽消耗。
支持二进制帧层（Binary Framing Layer），使得协议更加高效和灵活。
总之，HTTP/2 相较于 HTTP/1.1 和 HTTP/1.0，提供了更好的性能和用户体验。现代浏览器和服务器已经广泛支持 HTTP/2。


2. 状态码
1xx：代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。

2xx：代表请求已成功被服务器接收、理解并接受。

3xx：代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。

4xx：代表了客户端看起来可能发生了错误，妨碍了服务器的处理。

5xx：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。

常见的HTTP状态码包括：

200 OK：请求成功
201 Created：请求成功并创建了新的资源
204 No Content：请求成功但没有返回任何内容
301 Moved Permanently：永久重定向
302 Found：临时重定向
400 Bad Request：请求错误
401 Unauthorized：未授权
403 Forbidden：禁止访问
404 Not Found：未找到
500 Internal Server Error：服务器内部错误
502 Bad Gateway：网关错误
503 Service Unavailable：服务不可用
这些状态码可以帮助客户端更好地理解服务器的响应，并采取适当的行动。



3. https 原理
- 握手阶段：
client(包含支持的密码套件、客户端随机数)=》Server 

server(TLS/SSL 证书以及 公钥， 选择的套件， 服务器随机数) => client
client(对证书的身份验证)
client(使用公钥加密一段 加密的随机数（预主秘钥）) =》 server (使用私钥解密)

会话秘钥 = 客户端随机数 + 服务器随机数 + 预主秘钥；
client(使用会话秘钥加密‘完成’) => server(使用会话秘钥解密)
server(使用会话秘钥加密‘完成’) => client(使用会话秘钥解密)

握手完成，开始数据传输；
- 优点:
安全性： 加密
完整性： 计算数据摘要


缓存控制： 缓存时间 + 失效校验
缓存时间：expires/ cache-control
失效校验： last-modify/Etag
```
## router的两种模式：
```js
hashRouter: url+#   location.hash   原理： window.onhashchange(){}
historyRouter: url  history.psuhState();
```
## vue
### diff
- 虚拟dom是一个对象，用来表示真实dom;
- 虚拟dom比真实dom快是不严谨的，应该是虚拟dom算法操作真实dom比直接操作真实dom性能高；
- 虚拟dom算法 = 虚拟dom + diff
总结： diff是一种对比算法算法通过对比新旧虚拟dom，找出修改的vnode，更新vnode对应的dom，从而实现精准更新dom;

- 使用虚拟dom算法的损耗：虚拟dom的增、删、改 + 真实dom差异增、删、改 + 较少的节点重绘和回流
- 直接操作dom的损耗：真实dom完全的增、删、改 + （可能较多）排版/重绘

patchVnode(): 
1. 找到真实的dom为el；
2. 判断newVnode和oldVnode是否指向同一个对象，是return;
3.
### vue3与vue2的diff区别:
1. 静态提升： 使用 patchFlag 二进制数标记动态节点【文本、class、style、 props、 propsAll……】
2. diff比较
### vite 为什么比 webpack打包快
1. 原生 ES 模块支持：Vite 使用原生的 ES 模块（ECMAScript 模块）进行开发，这意味着在开发环境中，无需对代码进行打包，只需进行简单的转换即可。这大大减少了构建过程中的时间消耗。
2. 按需编译：Vite 采用了按需编译的策略，只有在需要时才会编译和打包代码。这意味着在开发过程中，只有修改过的文件才会被编译，从而大大减少了编译时间。
3. 插件系统：Vite 提供了一个简单易用的插件系统，可以方便地扩展其功能。通过使用插件，可以进一步优化构建过程，提高打包速度。
4. 优化的构建过程：Vite 在生产环境中使用了 Rollup 进行打包，Rollup 是一个高效的打包工具，具有更快的构建速度。Vite 还提供了一些额外的优化策略，如代码分割、Tree Shaking 等，进一步提高了构建速度。
5. 缓存：Vite 使用了缓存机制，可以将编译结果缓存起来，从而在下次构建时直接使用缓存，避免重复编译。
综上所述，Vite 之所以比 Webpack 打包快，主要是因为它采用了原生 ES 模块、按需编译、插件系统等优化策略，以及使用了高效的 Rollup 打包工具。然而，需要注意的是，Vite 目前还处于发展阶段，可能在某些方面（如插件生态、社区支持等）与 Webpack 相比仍有差距。在实际项目中，可以根据需求和场景选择合适的构建工具。
### vite 实现原理
Vite 是一种基于原生 ES 模块（ESM）的 Web 开发构建工具，由 Evan You 创建。它旨在解决传统 bundler（如 Webpack 或 Rollup）在开发过程中面临的一些挑战，如构建速度慢、模块热更新效率低等。Vite 的核心理念是实现模块的快速加载和按需编译，以提高开发效率。

Vite 的实现原理主要包括以下几个方面：

1. **基于原生 ES 模块**：Vite 使用原生 ES 模块作为构建和运行时的基础。这意味着开发者可以直接在项目中导入 ESM，而不需要额外的转换步骤。这有助于提高构建速度和运行时性能。

2. **依赖预构建**：Vite 在构建过程中会将项目的依赖项预先构建成优化的代码。这样，在开发过程中，Vite 可以直接加载这些预构建的依赖项，而无需进行实时编译。这大大加快了模块的加载速度。

3. **HMR（Hot Module Replacement）优化**：Vite 对 HMR 进行了优化，使其能够更快地更新模块。当源代码发生变化时，Vite 只会重新编译和加载发生变化的模块，而不是整个应用。这有助于提高开发效率。

4. **代码拆分**：Vite 支持代码拆分（Code Splitting），可以将大型应用拆分为多个较小的模块。这有助于减少首次加载的时间，提高应用的性能。

5. **插件系统**：Vite 提供了一个灵活的插件系统，允许开发者自定义构建过程、扩展功能等。这使得 Vite 可以很好地与其他工具和库集成。

6. **支持多种框架**：Vite 支持多种前端框架，如 React、Vue、Svelte 等。这使得开发者可以根据自己的需求选择合适的框架进行开发。

总之，Vite 的实现原理主要包括基于原生 ES 模块、依赖预构建、HMR 优化、代码拆分、插件系统和多框架支持等方面。这些特性使得 Vite 成为了一种高效、快速的 Web 开发构建工具。
## new过程发生了什么，实现一下
```
1. 创建一个 new Object();
2. {}.__prorto__ = constructor.protoType;
3. constructor.apply({})
```
## 构建工具
### webpack
1. 构建效率优化
- 缓存（catch-loader）
- 多线程
- 静态库预编译dll
- 使用代码分割，提取文件
- 使用 Tree Shaking
- 使用 externals

# 优化：
## 虚拟列表：
1. 可视区、可滚动区、列表项
- 样例： 1w => 【优化前2s多 =》 后17ms】 5w => 【前9s 后58ms】
# 代码管理
1. 单体库

# 项目
1. 空间编辑器:

识别=》 预览=》 编辑=》 生成
问题：
优化：

2. 积木平台:

- 简介：
- 负责：
  ```js
  RBAC:  基于角色的权限控制；  用户/用户组 =》角色 =》 权限(路由、页面、菜单、按钮、接口)
 错误码统一： 定义error.json => ts/java Error类模板 =》 node读取error.json和模板 =》 通过mastch
```
- 难点：
- 解决方案：
2. 空间编辑器

- 微前端：qiankun
注册子应用、启动主应用、是否激活子应用、初始化子应用、挂载子应用

构建、 加载、 渲染
构建： webpack打包优化  19s => 6s
```js
- 缓存（catch-loader）
- 多线程
- 静态库预编译dll
- 使用代码分割，提取文件
- 使用 Tree Shaking
- 使用 externals
```
加载：
```js
// 静态资源的加载、hash缓存浏览器更新
1. 主应用与子应用提取公共资源CDN 【业务包： 1M =》 200k, 加载时间2s => 600ms】
``` 
日志渲染： 
```js
// 虚拟列表、webworker、消息中心
// 虚拟列表：
1. 可视区、可滚动区、列表项
- 案例： 1w => 【优化前2s多 =》 后17ms】 5w => 【前9s 后58ms】
```







# 微前端、低代码、webgl、webassembly、vue、react、小程序、公众号、短视频


治疗方案：



日志 =》 等级 =》 是否离线 =》 本地存储 =》 联网日志上传

服务日志打印
操作日志管理：  登录、退出、操作、异常、错误、警告、提示、成功、失败